=== "./js/tableManager.js" ===
class TableManager {
    constructor(tableId, columns, data = [], filters = {}, selectedItems = [], contextMenuOptions = [], defaultSort = null, allowMultipleSelection = true, onItemClick = null) {
        this.tableId = tableId;
        this.columns = columns;
        this.data = data;
        this.filters = filters;
        this.selectedItems = selectedItems;
        this.contextMenuOptions = contextMenuOptions;
        this.defaultSort = defaultSort;
        this.allowMultipleSelection = allowMultipleSelection;
        this.onItemClick = onItemClick; // Función opcional a ejecutar al hacer clic en un ítem
        this.initTable();
        this.loadStoredFilters();

        if (this.defaultSort) {
            this.sortItems(this.defaultSort.columnId, this.defaultSort.order);
        }
    }

    // Inicializa la tabla
    initTable() {
        this.renderTable();
        this.applyFilters();
        this.attachEventListeners();
    }

    // Renderiza la tabla
    renderTable(filteredData = this.data) {
        const table = document.getElementById(this.tableId);
        table.innerHTML = '';

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        this.columns.forEach(col => {
            const th = document.createElement('th');
            th.textContent = col.name;
            th.dataset.columnId = col.id;
            if (col.sortable) {
                th.classList.add('sortable');
                th.addEventListener('click', () => {
                    this.sortItems(col.id);
                });
            }
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        filteredData.forEach(item => {
            const row = document.createElement('tr');
            row.dataset.itemId = item.id;
            this.columns.forEach(col => {
                const td = document.createElement('td');
                td.textContent = item[col.id];
                row.appendChild(td);
            });
            tbody.appendChild(row);
        });
        table.appendChild(tbody);

        this.updateSelectedUI();
        this.updateSortUI(); // Ensure the sort UI is updated after rendering
    }

    

    // Aplica los filtros a los datos
    applyFilters() {
        const filteredData = this.data.filter(item => {
            return Object.keys(this.filters).every(key => {
                const filterValue = this.filters[key];
                if (!filterValue) return true;
                return item[key].toLowerCase().includes(filterValue.toLowerCase());
            });
        });
        this.renderTable(filteredData);
    }

    // Almacena la configuración de los filtros aplicados
    saveFilters() {
        localStorage.setItem(`${this.tableId}-filters`, JSON.stringify(this.filters));
    }

    // Carga la configuración de filtros almacenada
    loadStoredFilters() {
        const storedFilters = JSON.parse(localStorage.getItem(`${this.tableId}-filters`));
        if (storedFilters) {
            this.filters = storedFilters;
            this.applyFilters();
        }
    }

    // Actualiza la tabla con nuevos datos
    updateData(newData) {
        this.data = newData;
        this.applyFilters();
    }

    // Actualiza los filtros y vuelve a renderizar la tabla
    updateFilters(newFilters) {
        this.filters = { ...this.filters, ...newFilters };
        this.saveFilters();
        this.applyFilters();
    }

    // Método para ordenar los ítems
    sortItems(columnId, order) {
        // Toggle the order if not specified
        if (!order) {
            order = this.currentSortColumn === columnId && this.currentSortOrder === 'asc' ? 'desc' : 'asc';
        }

        this.currentSortColumn = columnId;
        this.currentSortOrder = order;

        this.data.sort((a, b) => {
            const aValue = a[columnId];
            const bValue = b[columnId];

            if (aValue < bValue) return order === 'asc' ? -1 : 1;
            if (aValue > bValue) return order === 'asc' ? 1 : -1;
            return 0;
        });

        this.renderTable();
        this.updateSortUI();
    }

    updateSortUI() {
        const headers = document.querySelectorAll(`#${this.tableId} th`);
        headers.forEach(th => {
            th.classList.remove('sort-asc', 'sort-desc');
            if (th.dataset.columnId === this.currentSortColumn) {
                th.classList.add(`sort-${this.currentSortOrder}`);
            }
        });
    }

    // Maneja la selección de un ítem
    selectItem(itemId) {
        const item = this.data.find(item => item.id === parseInt(itemId, 10));

        if (this.allowMultipleSelection) {
            const itemIndex = this.selectedItems.indexOf(item);
            if (itemIndex > -1) {
                this.selectedItems.splice(itemIndex, 1); // Deseleccionar el ítem si ya estaba seleccionado
            } else {
                this.selectedItems.push(item); // Seleccionar el ítem
            }
        } else {
            if (this.selectedItems.includes(item)) {
                this.selectedItems = []; // Deseleccionar el ítem si ya estaba seleccionado
            } else {
                this.selectedItems = [item]; // Seleccionar el ítem
            }
        }

        this.updateSelectedUI();
    }

    // Actualiza la UI de ítems seleccionados
    updateSelectedUI() {
        const rows = document.querySelectorAll(`#${this.tableId} tbody tr`);
        rows.forEach(row => {
            const itemId = parseInt(row.dataset.itemId, 10);
            if (this.selectedItems.some(item => item.id === itemId)) {
                row.classList.add('selected');
            } else {
                row.classList.remove('selected');
            }
        });
    }

    // Obtiene los ítems seleccionados
    getSelectedItems() {
        return this.selectedItems;
    }

    // Muestra el menú contextual
    showContextMenu(event, itemId) {
        event.preventDefault();

        // Eliminar cualquier menú contextual existente
        const existingMenu = document.querySelector('.context-menu');
        if (existingMenu) {
            existingMenu.remove();
        }

        const contextMenu = document.createElement('div');
        contextMenu.classList.add('context-menu');

        this.contextMenuOptions.forEach(option => {
            const menuItem = document.createElement('div');
            menuItem.classList.add('context-menu-item');
            menuItem.textContent = option.label;
            menuItem.addEventListener('click', () => {
                option.action(itemId);
                contextMenu.remove(); // Eliminar el menú después de hacer clic en una opción
            });
            contextMenu.appendChild(menuItem);
        });

        document.body.appendChild(contextMenu);

        const { clientX: mouseX, clientY: mouseY } = event;
        const { clientWidth: menuWidth, clientHeight: menuHeight } = contextMenu;

        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Asegurar que el menú no salga de la ventana
        contextMenu.style.top = `${mouseY + menuHeight > windowHeight ? windowHeight - menuHeight : mouseY}px`;
        contextMenu.style.left = `${mouseX + menuWidth > windowWidth ? windowWidth - menuWidth : mouseX}px`;

        // Ocultar el menú al hacer clic en otro lugar
        document.addEventListener('click', () => {
            contextMenu.remove();
        }, { once: true });
    }
    // Añade o quita columnas de la tabla
    updateColumns(newColumns) {
        this.columns = newColumns;
        this.renderTable();
    }

    // Adjunta los event listeners necesarios
    attachEventListeners() {
        const table = document.getElementById(this.tableId);

        // Evento para manejar la selección de ítems
        table.addEventListener('click', event => {
            if (event.target.tagName === 'TD') {
                const row = event.target.parentElement;
                this.selectItem(row.dataset.itemId);
                if (this.onItemClick) {
                    this.onItemClick(row.dataset.itemId); // Ejecuta la función parametrizada
                }
            }
        });

        // Evento para manejar el menú contextual
        table.addEventListener('contextmenu', event => {
            if (this.contextMenuOptions.length > 0) {
                if (event.target.tagName === 'TD') {
                    const row = event.target.parentElement;
                    this.showContextMenu(event, row.dataset.itemId);
                }
            } else {
                event.preventDefault(); // Prevenir el menú contextual por defecto si no hay opciones definidas
            }
        });
    }

    clearSelection() {
        this.selectedItems = [];
        this.updateSelectedUI();
    }
}
=== "./js/storageDB.js" ===
var CLIENT_ID = "654333069607-t118hpn2v2ui383h9fcfpo0aspiv4tva.apps.googleusercontent.com";


class StorageDB {
    constructor(encryptionKey = null) {
        this.encryptionKey = encryptionKey;
        this.storage = localStorage;
    }

    // Establece un valor en la base de datos
    set(key, value) {
        let data = JSON.stringify(value);
        if (this.encryptionKey) {
            data = this.encrypt(data);
        }
        this.storage.setItem(key, data);
    }

    // Obtiene un valor de la base de datos
    get(key) {
        let data = this.storage.getItem(key);
        if (!data) return null; // Si no hay datos, devuelve null

        if (this.encryptionKey) {
            data = this.decrypt(data);
        }
        try {
            return JSON.parse(data);
        } catch (e) {
            console.error(`Error parsing data for key ${key}:`, e);
            this.remove(key); // Remover el valor corrupto del almacenamiento
            return null; // Devolver null si ocurre un error al parsear
        }
    }

    // Elimina un valor de la base de datos
    remove(key) {
        this.storage.removeItem(key);
    }

    // Limpia la base de datos
    clear() {
        this.storage.clear();
    }

    // Método para encriptar datos usando XOR
    encrypt(data) {
        return data.split('').map((char, i) => {
            return String.fromCharCode(char.charCodeAt(0) ^ this.encryptionKey.charCodeAt(i % this.encryptionKey.length));
        }).join('');
    }

    // Método para desencriptar datos usando XOR
    decrypt(data) {
        return this.encrypt(data); // XOR es reversible de la misma manera
    }

    // Decodifica un JWT
    parseJwt(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = decodeURIComponent(atob(base64Url).split('').map(function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
            return JSON.parse(base64);
        } catch (e) {
            console.error("Error parsing JWT:", e);
            return null;
        }
    }

    // Verifica si un token JWT sigue siendo válido
    isGtokenValid(token) {
        const decoded = this.parseJwt(token);
        if (!decoded) return false; // Si el token no se pudo decodificar, no es válido
        const currentTime = Math.floor(Date.now() / 1000);
        return decoded.exp > currentTime;
    }

    // Verifica si el token de Google ID necesita ser renovado
    checkGtoken() {
        const googleIdToken = this.get('google_id_token');
        return !googleIdToken || !this.isGtokenValid(googleIdToken);
    }
}
=== "./js/index.js" ===
document.addEventListener('DOMContentLoaded', async () => {
    const encryptionKey = 'my-global-secret-key';
    window.appManager = new AppManager(encryptionKey);
    window.sessionManager = appManager.sessionManager;

    if (!await sessionManager.isSessionActive()) {
        sessionManager.login();
    } else {
        appManager.loadInitialView();
    }
    

    // Precargar vistas más utilizadas
    appManager.preLoadViews(['apps', 'signin', 'settings']);

    const currentHash = window.location.hash.substring(1);
    if (currentHash) {
        const viewTitle = appManager.getAppNameById(currentHash);
        appManager.loadView(currentHash, viewTitle);
    } else {
        appManager.loadInitialView();
    }

    // Manejar clicks en botones del menú principal
    document.getElementById('apps').addEventListener('click', () => {
        appManager.loadView('apps', 'Apps');
    });

    document.getElementById('settings').addEventListener('click', () => {
        appManager.loadView('settings', 'Settings');
    });

    document.getElementById('help').addEventListener('click', () => {
        appManager.loadView('help', 'Help');
    });
});
=== "./js/appManager.js" ===
console.log("Ver: 3.3")

class AppManager {
    constructor(encryptionKey) {
        this.encryptionKey = encryptionKey;
        this.encryptedDB = new StorageDB(encryptionKey);
        this.unencryptedDB = new StorageDB();
        this.sessionManager = new SessionManager(this);
        this.isLoading = false;
    }

    async initializeApp() {
        this.sessionManager.initialize();
        this.handleHashChange(); // Llamada correcta a la función
    }

    loadInitialView() {
        if (!this.sessionManager.isSessionActive()) {
            this.loadView('signin', 'Sign In');
        } else {
            this.loadView('apps', 'Apps');
        }
    }

    preLoadViews(viewNames) {
        for (let viewName of viewNames) {
            try {
                fetch(`views/${viewName}/${viewName}.html`);
                const link = document.createElement('link');
                link.rel = 'prefetch';
                link.href = `views/${viewName}/${viewName}.css`;
                document.head.appendChild(link);

                const script = document.createElement('script');
                script.src = `views/${viewName}/${viewName}.js`;
                script.defer = true;
                script.setAttribute('data-view-script', '');
                document.body.appendChild(script);
            } catch (error) {
                console.error(`Error preloading view ${viewName}:`, error);
            }
        }
    }

    loadView(viewName, viewTitle) {
        if (this.isLoading) return;
        this.isLoading = true;

        console.log(`Loading view: ${viewName}`);

        const contentDiv = document.getElementById('content');
        contentDiv.style.opacity = 0;

        this.removePreviousAssets();

        setTimeout(() => {
            fetch(`views/${viewName}/${viewName}.html`)
                .then(response => response.text())
                .then(html => {
                    contentDiv.innerHTML = html;

                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = `views/${viewName}/${viewName}.css`;
                    link.setAttribute('data-view-style', '');
                    document.head.appendChild(link);

                    const script = document.createElement('script');
                    script.src = `views/${viewName}/${viewName}.js`;
                    script.defer = true;
                    script.setAttribute('data-view-script', '');
                    script.onload = () => {
                        if (typeof initializeView === 'function') {
                            initializeView();
                        }
                        this.isLoading = false;
                    };
                    contentDiv.style.opacity = 1;
                    document.body.appendChild(script);

                    document.title = viewTitle;
                })
                .catch(error => {
                    console.error('Error al cargar la vista:', error);
                    this.isLoading = false;
                });
        }, 100);
    }

    removePreviousAssets() {
        const oldLink = document.querySelector('link[data-view-style]');
        if (oldLink) {
            oldLink.remove();
        }

        const oldScripts = document.querySelectorAll('script[data-view-script]');
        oldScripts.forEach(script => script.remove());
    }

    clearAllData() {
        this.encryptedDB.clear();
        this.unencryptedDB.clear();
    }

    handleHashChange() {
        window.addEventListener('hashchange', () => {
            const currentHash = window.location.hash.substring(1);
            if (currentHash && !this.isLoading) {
                const viewTitle = this.getAppNameById(currentHash);
                this.loadView(currentHash, viewTitle);
            }
        });
    }

    getAppNameById(id) {
        const app = window.apps.find(app => app.id === id);
        return app ? app.name : 'Unknown';
    }

    async performAuthenticatedOperation(operation) {
        await this.sessionManager.checkAndPromptAuth();
        const accessToken = await this.sessionManager.getAccessToken();
        if (accessToken) {
            return operation(accessToken);
        } else {
            console.error('Failed to get access token');
            return null;
        }
    }

    async fetchCalendarEvents(calendarId, timeMin, timeMax) {
        return this.performAuthenticatedOperation(async (accessToken) => {
            const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${timeMin}&timeMax=${timeMax}`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            });
            if (!response.ok) {
                throw new Error('Failed to fetch calendar events');
            }
            return response.json();
        });
    }

    async createCalendarEvent(calendarId, event) {
        return this.performAuthenticatedOperation(async (accessToken) => {
            const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(event)
            });
            if (!response.ok) {
                throw new Error('Failed to create calendar event');
            }
            return response.json();
        });
    }
}
=== "./js/SessionsManager.js" ===
class SessionManager {
    constructor(appManager) {
        this.appManager = appManager;

        const winLocationOrigin = window.location.origin + "/Portal";

        const oidcSettings = {
            authority: "https://accounts.google.com",
            client_id: CLIENT_ID,
            redirect_uri: window.location.origin + "/Portal/auth/callback.html",
            response_type: "code",
            scope: "openid profile email",
            loadUserInfo: true,
            post_logout_redirect_uri: window.location.origin + "/Portal",
            automaticSilentRenew: true,
            silent_redirect_uri: window.location.origin + "/Portal/auth/silent-renew.html",
            userStore: new Oidc.WebStorageStateStore({ store: window.sessionStorage })  // Usa sessionStorage en lugar de localStorage
        };
        
        
        this.userManager = new Oidc.UserManager(oidcSettings);
        


    }

    // Método para inicializar la autenticación
    async initialize() {
        try {
            const user = await this.userManager.getUser();
            if (user) {
                console.log("User is logged in", user);
                this.storeUser(user);
                this.updateUIWithUserProfile();
            } else {
                console.log("User is not logged in");
            }
        } catch (error) {
            console.error("Error during initialization", error);
        }
    }

    // Iniciar sesión
    login() {
        this.userManager.signinRedirect();
    }

    // Manejar el callback después de la autenticación
    async handleCallback() {
        try {
            const user = await this.userManager.signinRedirectCallback();
            this.storeUser(user);
            window.location.href = "/";
        } catch (error) {
            console.error("Error handling callback", error);
        }
    }

    // Logout
    logout() {
        this.userManager.signoutRedirect();
    }

    // Almacena los datos del usuario
    storeUser(user) {
        this.appManager.encryptedDB.set('google_user', user);
    }

    // Recupera el ID token almacenado
    getIdToken() {
        const user = this.appManager.encryptedDB.get('google_user');
        return user ? user.id_token : null;
    }

    // Recupera el access token almacenado
    getAccessToken() {
        const user = this.appManager.encryptedDB.get('google_user');
        return user ? user.access_token : null;
    }

    // Actualiza la UI con la información del perfil del usuario
    updateUIWithUserProfile() {
        const user = this.appManager.encryptedDB.get('google_user');
        if (user) {
            const profile = user.profile;
            document.getElementById('user-name').textContent = profile.name;
            document.getElementById('user-image').src = profile.picture;
            document.getElementById('user-image').style.display = "block";
            document.getElementById('user-name').style.display = "block";
        }
    }

    // Verifica si la sesión está activa
    async isSessionActive() {
        const user = await this.userManager.getUser();
        return !!user && !user.expired;
    }

    // Maneja la renovación silenciosa del token
    handleSilentRenew() {
        this.userManager.signinSilentCallback().then(() => {
            console.log("Silent renew successful");
        }).catch(error => {
            console.error("Error during silent renew", error);
        });
    }
}
=== "./js/appList.js" ===
window.apps = [
    {
        id: 'worklog-manager',
        name: 'Worklog Manager',
        comment: 'Manage your worklogs',
        group: 'public'
    },
    {
        id: 'settings',
        name: 'Settings',
        comment: 'Adjust your Portal settings',
        group: 'public'
    },
    {
        id: 'help',
        name: 'Help',
        comment: 'Find help and documentation',
        group: 'public'
    },
    {
        id: 'apps',
        name: 'Apps',
        comment: 'Select an Application',
        group: 'system'
    },
    {
        id: 'signin',
        name: 'Sign in',
        comment: 'Google one tap login view',
        group: 'home'
    },
    {
        id: 'loading',
        name: 'Loading...',
        comment: 'View shown when a view change (only for system)',
        group: 'system'
    }
];
=== "./views/settings/settings.js" ===
function initializeView() {
    const jiraTokenInput = document.getElementById('jira-token-input');
    const saveJiraTokenBtn = document.getElementById('save-jira-token-btn');
    const deleteJiraTokenBtn = document.getElementById('delete-jira-token-btn');
    const toggleJiraTokenVisibility = document.getElementById('toggle-jira-token-visibility');
    const jiraTokenStatus = document.getElementById('jira-token-status');
    const logoutBtn = document.getElementById('logout-btn');
    const clearDataBtn = document.getElementById('clear-data-btn');

    const encryptionKey = 'my-global-secret-key';
    const appManager = new AppManager(encryptionKey);

    // Verificar si el usuario está autenticado
    const idToken = appManager.unencryptedDB.get('google_id_token');
    if (!idToken) {
        alert('You must be logged in to manage tokens.');
        appManager.loadView('signin', 'Sign In');
        return;
    }

    // Mostrar el estado del token de Jira
    if (appManager.encryptedDB.get('jira_token')) {
        jiraTokenStatus.textContent = 'Token stored';
        jiraTokenStatus.style.color = 'green';
    } else {
        jiraTokenStatus.textContent = 'No token stored';
        jiraTokenStatus.style.color = 'red';
    }

    // Guardar el token de Jira
    saveJiraTokenBtn.addEventListener('click', () => {
        const token = jiraTokenInput.value;
        appManager.encryptedDB.set('jira_token', token);
        jiraTokenStatus.textContent = 'Token stored';
        jiraTokenStatus.style.color = 'green';
        alert('Jira token saved successfully.');
    });

    // Eliminar el token de Jira
    deleteJiraTokenBtn.addEventListener('click', () => {
        appManager.encryptedDB.remove('jira_token');
        jiraTokenStatus.textContent = 'No token stored';
        jiraTokenStatus.style.color = 'red';
        alert('Jira token deleted successfully.');
    });

    // Cerrar sesión
    logoutBtn.addEventListener('click', () => {
        sessionManager.logout();
    });

    // Limpiar todos los datos locales
    clearDataBtn.addEventListener('click', () => {
        appManager.clearAllData();
        alert('All data cleared.');
    });

    // Alternar la visibilidad del token de Jira
    toggleJiraTokenVisibility.addEventListener('click', () => {
        if (jiraTokenInput.type === 'password') {
            jiraTokenInput.type = 'text';
            toggleJiraTokenVisibility.textContent = 'Hide';
        } else {
            jiraTokenInput.type = 'password';
            toggleJiraTokenVisibility.textContent = 'Show';
        }
    });
}
=== "./views/loading/settings.js" ===
function initializeView() {


}



=== "./views/worklog-manager/worklog-manager.js" ===
function initializeView() {
    const issuesTable = new TableManager(
        'issuesTable',
        [
            { id: 'summary', name: 'Summary', sortable: true },
            { id: 'timeSpent', name: 'Time Spent', sortable: true },
            { id: 'link', name: 'Link', sortable: false },
            { id: 'status', name: 'Status', sortable: true }
        ],
        [], // Data se actualizará dinámicamente
        {}, // Filtros iniciales
        [], // Ítems seleccionados
        [    
            { label: 'View Details', action: (itemId) => viewDetails(itemId) },
            { label: 'Edit', action: (itemId) => editItem(itemId) },
            { label: 'Delete', action: (itemId) => deleteItem(itemId) }
        ], // Opciones del menú contextual
        { columnId: 'summary', order: 'asc' }, // Orden por defecto
        true, // Selección múltiple permitida
        handleItemClick // Función a ejecutar al hacer clic en un ítem
    );

    const eventsTable = new TableManager(
        'eventsTable',
        [
            { id: 'startTime', name: 'Start Time', sortable: true },
            { id: 'title', name: 'Title', sortable: true },
            { id: 'duration', name: 'Duration', sortable: false }
        ],
        [], // Data se actualizará dinámicamente
        {}, // Filtros iniciales
        [], // Ítems seleccionados
        [], // Opciones del menú contextual
        { columnId: 'startTime', order: 'asc' }, // Orden por defecto
        false, // Selección múltiple no permitida
        handleItemClick // Función a ejecutar al hacer clic en un ítem
    );

    // Eventos para actualizar issues y eventos
    document.getElementById('updateIssues-btn').addEventListener('click', () => updateIssues(issuesTable));
    document.getElementById('updateEvents-btn').addEventListener('click', () => updateEvents(eventsTable));

    // Evento para manejar la sincronización
    document.getElementById('syncButton').addEventListener('click', syncWorklog);

    // Cargar Issues y Eventos al inicio
    updateIssues(issuesTable);
    updateEvents(eventsTable);

    // Función para manejar el clic en un ítem de la tabla
    function handleItemClick(itemId) {
        checkSyncAvailability();
    }

    // Verifica si los botones de sync deben estar habilitados
    function checkSyncAvailability() {
        const syncButton = document.getElementById('syncButton');
        if (issuesTable.getSelectedItems().length > 0 && eventsTable.getSelectedItems().length > 0) {
            syncButton.disabled = false;
        } else {
            syncButton.disabled = true;
        }
    }

    // Actualiza la lista de issues desde Jira
    async function updateIssues(tableManager) {
        await appManager.performAuthenticatedOperation(async (accessToken) => {
            const jiraToken = appManager.encryptedDB.get('jira_token');
            if (!jiraToken) {
                alert('No Jira token found. Please add your Jira token in the Settings.');
                return;
            }

            // Llamada ficticia a la API de Jira para obtener los issues
            const issues = await fetchIssuesFromJira(jiraToken);
            tableManager.updateData(issues);
        });
    }

    // Actualiza la lista de eventos desde Google Calendar
    async function updateEvents(tableManager) {
        await appManager.performAuthenticatedOperation(async (accessToken) => {
            const calendarId = document.getElementById('calendar-select').value;
            const date = document.getElementById('date-input').value;

            // Llamada ficticia a la API de Google Calendar para obtener los eventos
            const events = await fetchEventsFromGoogleCalendar(accessToken, calendarId, date);
            tableManager.updateData(events);
        });
    }

    // Sincroniza el worklog de Jira con los eventos de Calendar
    async function syncWorklog() {
        const selectedIssue = issuesTable.getSelectedItems()[0];
        const selectedEvent = eventsTable.getSelectedItems()[0];
        const comment = document.getElementById('selectedEventComment').value;

        if (!selectedIssue || !selectedEvent) {
            alert('Please select both an issue and an event to sync.');
            return;
        }

        await appManager.performAuthenticatedOperation(async (accessToken) => {
            const jiraToken = appManager.encryptedDB.get('jira_token');
            if (!jiraToken) {
                alert('No Jira token found. Please add your Jira token in the Settings.');
                return;
            }

            // Llamada ficticia para sincronizar el worklog en Jira usando los datos seleccionados
            await syncWorklogToJira(jiraToken, selectedIssue, selectedEvent, comment);

            // Deshabilitar el botón de sync durante la sincronización
            document.getElementById('syncButton').disabled = true;

            setTimeout(() => {
                document.getElementById('syncButton').disabled = false;
                alert('Worklog synchronized successfully.');

                // Deseleccionar los ítems después de sincronizar
                issuesTable.clearSelection();
                eventsTable.clearSelection();
                document.getElementById('selectedEventComment').value = '';
            }, 2000);
        });
    }

    // Función ficticia para obtener issues de Jira
    async function fetchIssuesFromJira(jiraToken) {
        // Aquí harías la llamada real a la API de Jira
        return [
            { id: 1, summary: 'Issue 1', timeSpent: '2h', link: 'https://jira.example.com/1', status: 'Open' },
            { id: 2, summary: 'Issue 2', timeSpent: '1h', link: 'https://jira.example.com/2', status: 'In Progress' }
        ];
    }

    // Función ficticia para obtener eventos de Google Calendar
    async function fetchEventsFromGoogleCalendar(accessToken, calendarId, date) {
        // Aquí harías la llamada real a la API de Google Calendar
        return [
            { id: 1, startTime: '09:00 AM', title: 'Event 1', duration: '1h' },
            { id: 2, startTime: '11:00 AM', title: 'Event 2', duration: '2h' }
        ];
    }

    // Función ficticia para sincronizar el worklog en Jira
    async function syncWorklogToJira(jiraToken, issue, event, comment) {
        // Aquí harías la llamada real a la API de Jira para sincronizar el worklog
        console.log('Syncing worklog:', { jiraToken, issue, event, comment });
    }
}
=== "./views/signin/signin.js" ===
function initializeView() {
    const urlParams = new URLSearchParams(window.location.search);
    const authorizationCode = urlParams.get('code');

    if (authorizationCode) {
        sessionManager.fetchAccessToken(authorizationCode).then(accessToken => {
            if (accessToken) {
                sessionManager.storeAccessToken(accessToken);
                appManager.loadView('apps', 'Apps');
            } else {
                alert('Failed to obtain access token. Please try signing in again.');
                appManager.loadView('signin', 'Sign In');
            }
        });
    } else {
        const googleIdToken = sessionManager.getIdToken();
        const googleAccessToken = sessionManager.getAccessToken();

        if (googleIdToken && appManager.unencryptedDB.isGtokenValid(googleIdToken) &&
            googleAccessToken && sessionManager.validateAccessToken(googleAccessToken)) {

            const profile = appManager.unencryptedDB.get('user_profile');

            // Mostrar mensaje de que ya está autenticado
            document.getElementById('signInMessage').textContent = `You are already signed in as ${profile.name}.`;

            // Calcular y mostrar la fecha de expiración del token en la consola
            const decodedToken = appManager.unencryptedDB.parseJwt(googleIdToken);
            const expirationDate = new Date(decodedToken.exp * 1000);
            console.log(`Token expires at: ${expirationDate}`);

            // Ocultar el botón de iniciar sesión
            document.getElementById('signInButton').style.display = 'none';
        } else {
            // Renderizar el botón de Google Sign-In si no está autenticado
            google.accounts.id.renderButton(
                document.getElementById("signInButton"),
                { theme: "outline", size: "large", text: "signin", shape: "pill" }
            );

            google.accounts.id.prompt(); // Opcional: solicitar inicio de sesión automático
        }
    }
}
=== "./views/apps/apps.js" ===
function initializeView() {
  const appListContainer = document.getElementById('apps-list');
  const apps = window.apps.filter(app => app.group !== 'system');

  apps.forEach(app => {
      const appItem = document.createElement('div');
      appItem.className = 'app-item';
      appItem.onclick = () => {
          appManager.loadView(app.id, app.name);
      };

      const appTitle = document.createElement('h3');
      appTitle.textContent = app.name;

      const appDescription = document.createElement('p');
      appDescription.textContent = app.comment;

      appItem.appendChild(appTitle);
      appItem.appendChild(appDescription);
      appListContainer.appendChild(appItem);
  });
}
=== "./views/help/help.js" ===
function initializeView() {


}



